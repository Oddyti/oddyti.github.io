<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JAVA并发 on Oddyti的小站</title><link>https://oddyti.com/tags/java%E5%B9%B6%E5%8F%91/</link><description>Recent content in JAVA并发 on Oddyti的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Oddyti</copyright><lastBuildDate>Mon, 24 Feb 2025 21:14:04 +0800</lastBuildDate><atom:link href="https://oddyti.com/tags/java%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Java线程池(Thread Pool) - 一篇不太详细的解释</title><link>https://oddyti.com/post/thread-pool/</link><pubDate>Mon, 24 Feb 2025 21:14:04 +0800</pubDate><guid>https://oddyti.com/post/thread-pool/</guid><description>&lt;h2 id="线程池"&gt;线程池
&lt;/h2&gt;&lt;p&gt;使用线程池的主要原因：&lt;strong&gt;控制并发数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程池可以复用已经创建的线程，以降低资源消耗&lt;/li&gt;
&lt;li&gt;可以对线程做统一管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="threadpoolexecutor类"&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类是&lt;code&gt;Executor&lt;/code&gt;接口的实现类，&lt;code&gt;Executor&lt;/code&gt; 提供了一种标准的方式来运行任务（&lt;code&gt;Runnable&lt;/code&gt; 或 &lt;code&gt;Callable&lt;/code&gt;），而不需要手动创建和管理线程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Executor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;Executor&lt;/code&gt; 本身只是一个接口，它并不直接决定是否开辟新线程。是否开辟新线程取决于 &lt;code&gt;Executor&lt;/code&gt; 的具体实现。&lt;/p&gt;
&lt;p&gt;而**&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;**：使用线程池中的线程执行任务，不会为每个任务都开辟新线程（除非线程池需要扩展）。&lt;/p&gt;
&lt;h3 id="threadpoolexecutor核心概念"&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;核心概念：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;核心线程与非核心线程
&lt;ul&gt;
&lt;li&gt;线程池中有两类线程，核心线程和非核心线程。&lt;strong&gt;核心线程默认情况下会一直存在于线程池中&lt;/strong&gt;，即使这个核心线程什么都不干（&lt;strong&gt;铁饭碗&lt;/strong&gt;），而非核心线程如果长时间的闲置，就会被&lt;strong&gt;销毁&lt;/strong&gt;（&lt;strong&gt;临时工&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程工厂
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThreadFactory&lt;/code&gt; 创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="threadpoolexecutor构造方法"&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造方法
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;有四个构造方法，其参数主要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int corePoolSize&lt;/code&gt;：核心线程数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int maximumPoolSize&lt;/code&gt;：最大线程数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long keepAliveTime&lt;/code&gt;：非核心线程闲置超时时长。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlockingQueue workQueue&lt;/code&gt;：阻塞队列，维护着&lt;strong&gt;等待执行的Runnable任务对象&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;LinkedBlockingQueue：链式阻塞队列，底层数据结构是链表，默认大小是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，也可以指定大小。&lt;/li&gt;
&lt;li&gt;ArrayBlockingQueue：数组阻塞队列，底层数据结构是数组，需要指定队列的大小。&lt;/li&gt;
&lt;li&gt;SynchronousQueue：同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。&lt;/li&gt;
&lt;li&gt;DelayQueue：延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadFactory threadFactory&lt;/code&gt;：线程工厂。
&lt;ul&gt;
&lt;li&gt;创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RejectedExecutionHandler handler&lt;/code&gt;：拒绝策略。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拒绝处理策略&lt;/strong&gt;，线程数量大于最大线程数就会采用拒绝处理策略，一共有四种。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor.AbortPolicy：&lt;strong&gt;默认拒绝处理策略&lt;/strong&gt;，丢弃任务并抛出RejectedExecutionException异常。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="threadpoolexecutor线程池任务处理流程"&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;线程池任务处理流程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;任务提交：
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;execute(Runnable command)&lt;/code&gt; 方法提交任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断线程数是否小于核心线程数（&lt;code&gt;corePoolSize&lt;/code&gt;）：
&lt;ul&gt;
&lt;li&gt;如果当前线程数 &amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;，则创建&lt;strong&gt;核心线程&lt;/strong&gt;执行任务（优先让核心线程数快速达到上限值）。&lt;/li&gt;
&lt;li&gt;如果当前线程数 &amp;gt;= &lt;code&gt;corePoolSize&lt;/code&gt;，进入下一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果当前线程数 &amp;gt;= &lt;code&gt;corePoolSize&lt;/code&gt;，尝试将任务加入工作队列（&lt;code&gt;workQueue&lt;/code&gt;）：
&lt;ul&gt;
&lt;li&gt;新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了&lt;strong&gt;线程复用&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;如果工作队列已满，进入下一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果工作队列已满：
&lt;ul&gt;
&lt;li&gt;如果当前线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;，则创建新线程（即非核心线程，临时工）执行任务。&lt;/li&gt;
&lt;li&gt;如果当前线程数 &amp;gt;= &lt;code&gt;maximumPoolSize&lt;/code&gt;，进入下一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;触发拒绝策略（&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;）：
&lt;ul&gt;
&lt;li&gt;如果线程池无法接受新任务（线程数达到 &lt;code&gt;maximumPoolSize&lt;/code&gt; 且工作队列已满），根据设置的拒绝策略处理任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://oddyti.com/post/thread-pool/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"
width="947"
height="592"
loading="lazy"
alt="img"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="383px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;线程复用原理&lt;/p&gt;
&lt;p&gt;具体原理与源码解析移步 &lt;a class="link" href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/12#id-12.2-xian-cheng-chi-de-yuan-li" target="_blank" rel="noopener"
&gt;深入浅出Java多线程 - ThreadPoolExecutor如何做到线程复用的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里简单讲讲：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;在创建线程时，会将线程封装成&lt;strong&gt;工作线程worker&lt;/strong&gt;,并放入&lt;strong&gt;工作线程组&lt;/strong&gt;中，然后这个worker反复从阻塞队列中拿任务去执行。如果任务队列为空，线程会根据 &lt;code&gt;keepAliveTime&lt;/code&gt; 和 &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; 的设置决定是否等待或销毁。&lt;/p&gt;
&lt;h3 id="excutors类"&gt;&lt;code&gt;Excutors&lt;/code&gt;类
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Executors&lt;/code&gt; 是一个工具类，提供了静态工厂方法，用于创建不同类型的线程池。它的主要目的是简化线程池的创建，隐藏底层实现的复杂性。其基本方法主要都由&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Executors&lt;/code&gt; 是对 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的一种高层抽象，而 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 是线程池的核心实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里讲讲&lt;code&gt;Executors&lt;/code&gt; 工具类的四个静态方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;newFixedThreadPool(int nThreads)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个&lt;strong&gt;只有核心线程&lt;/strong&gt;且&lt;strong&gt;固定数量&lt;/strong&gt;的线程池，。适合任务数量稳定、需要控制并发数量的场景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;固定数量工人工厂，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于线程不会被回收，会一直卡在阻塞，所以&lt;strong&gt;没有任务的情况下， FixedThreadPool占用资源更多&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个可缓存的线程池，不创建核心线程，&lt;strong&gt;只创建非核心线程&lt;/strong&gt;，线程数量会根据任务数量动态调整。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有临时工工厂，有多少任务雇佣多少工人，工人一旦空闲就解雇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当需要执行很多&lt;strong&gt;短时间&lt;/strong&gt;的任务时，CacheThreadPool的线程复用率比较高， 会显著的&lt;strong&gt;提高性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;newSingleThreadExecutor()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个单线程的线程池，所有任务按顺序执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有且仅有一个核心线程&lt;/strong&gt;（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，&lt;strong&gt;不会创建非核心线程&lt;/strong&gt;。所有任务按照&lt;strong&gt;先来先执行&lt;/strong&gt;的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;newWorkStealingPool()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个定长线程池，支持定时及周期性任务执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;newWorkStealingPool()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建一个工作窃取线程池，使用 &lt;code&gt;ForkJoinPool&lt;/code&gt; 实现，适合并行处理任务。并不使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就像你开了一家团队协作公司，每个人（线程）不仅做自己的任务，还会偷别人的任务来做，效率更高。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Java内存模型(JMM) - 一篇不太详细的解释</title><link>https://oddyti.com/post/jmm/</link><pubDate>Sat, 22 Feb 2025 21:09:30 +0800</pubDate><guid>https://oddyti.com/post/jmm/</guid><description>&lt;h2 id="java内存模型jmm"&gt;Java内存模型(JMM)
&lt;/h2&gt;&lt;h3 id="运行时数据区"&gt;运行时数据区
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://oddyti.com/post/jmm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg"
width="552"
height="383"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="345px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程私有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由native修饰，由 C 语言实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器：它是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java虚拟机栈&lt;/strong&gt;：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法运行时的局部变量和操作数存储在 Java 虚拟机栈（JVM Stack）中，例如在方法穿进来的参数变量、方法中创建的变量、方法中创建的对象（存其指向堆对象的地址）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程共有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如创建对象时会在堆开辟空间存放对象，并将在虚拟机栈中存放该对象地址&lt;/li&gt;
&lt;li&gt;如常量池在堆中开辟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区（Java8叫元空间）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法区存储的是与类相关的元数据信息，包括类的结构（如类名、父类名、修饰符等）、字段信息、方法信息、运行时常量池等。&lt;/li&gt;
&lt;li&gt;如类的信息（有哪些字段、方法等等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="java内存模型"&gt;Java内存模型
&lt;/h3&gt;&lt;p&gt;如果要讲Java内存模型，需要先了解硬件内存模型，因为Java内存模型实际上是一种对硬件内存模型的“重新抽象与封装”&lt;/p&gt;
&lt;p&gt;&lt;img src="https://oddyti.com/post/jmm/image-20250323174724214.png"
width="1214"
height="972"
loading="lazy"
alt="image-20250323174724214"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="299px"
&gt;&lt;/p&gt;
&lt;p&gt;理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程一般来说对存在Stack的数据访问更频繁，所以Stack的数据大部分应该是在CPU寄存器、缓存中储存&lt;/li&gt;
&lt;li&gt;而Heap中的数据访问不那么频繁，所以Heap中的数据更可能在内存中存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在硬件模型中，CPU1会将数据D从主内存放到Cache1中，假设叫D1，并对D1进行修改，CPU2从主内存中将D取到Cache2中，假设叫D2，进行修改。如果CPU1修改D1后并没有即时更新D1到主内存的D中，那么CPU2就不会获得最新的D，便产生了数据不同步问题。针对这个问题，便有了缓存一致性协议。&lt;/p&gt;
&lt;p&gt;在Java内存模型中，可以抽象为以下模型。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://oddyti.com/post/jmm/JMM.jpeg"
width="1278"
height="998"
loading="lazy"
alt="img"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="307px"
&gt;&lt;/p&gt;
&lt;p&gt;线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的共享变量都存在主内存中。&lt;/li&gt;
&lt;li&gt;每个线程都保存了一份该线程使用到的共享变量的副本。&lt;/li&gt;
&lt;li&gt;如果线程A与线程B之间要通信的话，必须经历下面2个步骤：
&lt;ol&gt;
&lt;li&gt;线程A将本地内存A中更新过的共享变量刷新到主内存中去。&lt;/li&gt;
&lt;li&gt;线程B到主内存中去读取线程A之前已经更新过的共享变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而JMM规定，&lt;strong&gt;线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取&lt;/strong&gt;。即线程B需要先读取其本地内存变量，如果发现这个变量和主内存的变量不一致，才会去更新本地内存的变量，再读取本地内存的变量，&lt;strong&gt;而不是直接去读取主内存的变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而如何解决共享变量一致性问题，便是JMM的功能。&lt;/p&gt;
&lt;p&gt;即线程如何直到本地内存的变量已经被其他线程更新？即内存是否对其他线程可见？&lt;/p&gt;
&lt;p&gt;JMM出手：&lt;strong&gt;JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。&lt;/p&gt;
&lt;h4 id="顺序一致性模型-与-java-内存模型jmm"&gt;顺序一致性模型 与 Java 内存模型（JMM）
&lt;/h4&gt;&lt;h5 id="顺序一致性模型"&gt;顺序一致性模型
&lt;/h5&gt;&lt;p&gt;这里讲的顺序一致性模型是一种&lt;strong&gt;理论参考模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顺序一致性模型有两大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。&lt;/li&gt;
&lt;li&gt;不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是&lt;strong&gt;原子性的，且立刻对所有线程可见&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是如果线程A有A1,A2,A3三个操作，B有B1,B2,B3三个操作，如果在顺序一致性下，无论是否同步，线程各自的执行顺序都严格保证A1-A2-A3，B1-B2-B3，并且两个线程的各自的三个&lt;strong&gt;操作都对任意线程可见&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;思考是否有缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有顺序都&lt;strong&gt;严格按照顺序串行执行&lt;/strong&gt;，那么像处理器流水线机制是否无法发挥提高效率作用？&lt;/li&gt;
&lt;li&gt;如果所有线程自己的操作都&lt;strong&gt;对所有线程可见&lt;/strong&gt;，即每次写操作都立即刷新到主内存，这是否增大了性能开销？&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="java-内存模型jmm"&gt;Java 内存模型（JMM）
&lt;/h5&gt;&lt;p&gt;考虑到顺序一致性模型的两个缺点，JMM内存模型并没有严格按照顺序一致性模型，而是有一些区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是未同步情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果）&lt;/li&gt;
&lt;li&gt;顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果是同步情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将同步块或者同步方法包含的代码区域成为临界区（被 &lt;code&gt;synchronized&lt;/code&gt; 关键字修饰)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临界区内的代码，JMM允许重排序以提高性能，只要不改变程序结果&lt;/li&gt;
&lt;li&gt;但是不能将临界区内的写操作重排序到临界区外&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，当线程进入或者退出临界区时，会进行特殊处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进入临界区&lt;/strong&gt;：当一个线程进入临界区时，JMM会确保该线程能看到所有之前对共享变量的修改。这通常通过刷新线程的本地缓存（从主内存中读取最新的值）来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出临界区&lt;/strong&gt;：当一个线程退出临界区时，JMM会确保该线程对共享变量的修改对其他线程可见。这通常通过将线程的本地缓存写回主内存来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;即在临界区内，线程看到的所有共享变量的值都是最新的&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id="jmm对64位变量long和double的原子性处理"&gt;JMM对64位变量（long和double）的原子性处理
&lt;/h5&gt;&lt;p&gt;JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读写操作都具有原子性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非原子性&lt;/strong&gt;：在JMM中，对64位的&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;类型变量的写操作&lt;strong&gt;不保证原子性&lt;/strong&gt;。这意味着，如果一个线程正在写入一个&lt;code&gt;long&lt;/code&gt;或&lt;code&gt;double&lt;/code&gt;变量，另一个线程可能会看到该变量的&lt;strong&gt;部分写入值&lt;/strong&gt;（即只看到高32位或低32位）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：这种设计主要是为了在某些硬件平台上提高性能。一些32位平台可能无法以原子方式处理64位数据，因此JMM选择不强制要求对&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;的写操作具有原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，假设我们有一个&lt;code&gt;long&lt;/code&gt;变量，其值为&lt;code&gt;0x123456789ABCDEF0&lt;/code&gt;（64位）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一步&lt;/strong&gt;：写入低32位（&lt;code&gt;0x9ABCDEF0&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二步&lt;/strong&gt;：写入高32位（&lt;code&gt;0x12345678&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在这个过程中没有同步机制（如&lt;code&gt;volatile&lt;/code&gt;或&lt;code&gt;synchronized&lt;/code&gt;），另一个线程可能会看到中间状态，例如只看到低32位被写入，而高32位仍然是旧值。&lt;/p&gt;
&lt;h4 id="最小安全性"&gt;最小安全性
&lt;/h4&gt;&lt;p&gt;最小安全性是指，在多线程环境中，即使没有显式的同步机制，程序的行为也不会完全失控。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程读取到的值必须是之前某个线程写入的值，或者是默认值（如&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;等）。&lt;/li&gt;
&lt;li&gt;线程不会凭空（Out-of-Thin-Air）读取到一个完全不合理或未定义的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实现这个安全性，JVM在堆上分配对象时，首先会对内存&lt;strong&gt;空间清零&lt;/strong&gt;，然后才会在上面分配对象（这两个操作是同步的）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;空间清零&lt;/p&gt;
&lt;p&gt;Memory Zeroing: 实际上翻译有所误解，Zeroing指设置默认值为0或其他默认值，并非清零&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="happens-before原则"&gt;happens-before原则
&lt;/h4&gt;&lt;p&gt;为了解放程序员，让程序员在开发时尽量不用考虑内存可见和指令重排问题，JMM提供了happens-before原则，只要程序员按照这个原则写代码，则程序就能保证在JMM中具有强的内存可见性。&lt;/p&gt;
&lt;p&gt;happens-before关系的定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果多线程情景下，线程1执行writer()方法，线程2执行reader()方法，并没有考虑happens-before原则，会出现以下可能问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存可见性问题：在多线程环境中，每个线程可能会在自己的本地缓存中操作变量，而不是直接从主内存中读取或写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writer&lt;/code&gt;线程对&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;flag&lt;/code&gt;的修改可能不会立即刷新到主内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reader&lt;/code&gt;线程可能读取到&lt;code&gt;flag&lt;/code&gt;和&lt;code&gt;x&lt;/code&gt;的过期值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令重排序问题：编译器和处理器可能会对指令进行重排序以优化性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writer&lt;/code&gt;方法中的&lt;code&gt;x = 42&lt;/code&gt;和&lt;code&gt;flag = true&lt;/code&gt;可能会被重排序，导致&lt;code&gt;flag = true&lt;/code&gt;先执行，而&lt;code&gt;x = 42&lt;/code&gt;后执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reader&lt;/code&gt;线程可能看到&lt;code&gt;flag&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，但&lt;code&gt;x&lt;/code&gt;的值仍然是&lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要实现happens-before原则，可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;flag&lt;/code&gt;声明为&lt;code&gt;volatile&lt;/code&gt;，可以确保&lt;code&gt;writer&lt;/code&gt;线程对&lt;code&gt;flag&lt;/code&gt;的修改对&lt;code&gt;reader&lt;/code&gt;线程可见，并且禁止指令重排序。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;synchronized&lt;/code&gt;块保护&lt;code&gt;writer&lt;/code&gt;和&lt;code&gt;reader&lt;/code&gt;方法，可以确保内存可见性和原子性。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Lock&lt;/code&gt;显式控制临界区，可以确保内存可见性和原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="内存屏障"&gt;内存屏障
&lt;/h4&gt;&lt;p&gt;内存屏障是实现happens-before关系的技术手段，而happens-before是内存屏障在JMM中的高层抽象。&lt;/p&gt;
&lt;p&gt;内存屏障是JMM实现happens-before原则的机制。上文提到的通过&lt;code&gt;volatile&lt;/code&gt;或通过&lt;code&gt;synchronized&lt;/code&gt;块等方法便是使用了内存屏障机制。&lt;/p&gt;
&lt;p&gt;后文会详解&lt;code&gt;volatile&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h4 id="volatitle关键字"&gt;volatitle关键字
&lt;/h4&gt;&lt;p&gt;在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证变量的&lt;strong&gt;内存可见性&lt;/strong&gt;（即当该变量被某个线程修改之后，另一个线程可以正确获取修改后的值）&lt;/li&gt;
&lt;li&gt;禁止volatile变量与普通变量&lt;strong&gt;重排序&lt;/strong&gt;（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="具体机制"&gt;具体机制
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;内存可见性保证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓内存可见性，指的是当一个线程对&lt;code&gt;volatile&lt;/code&gt;修饰的变量进行&lt;strong&gt;写操作&lt;/strong&gt;时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；&lt;/p&gt;
&lt;p&gt;当一个线程对&lt;code&gt;volatile&lt;/code&gt;修饰的变量进行&lt;strong&gt;读操作&lt;/strong&gt;（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;禁止重排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JSR133之后：严格限制编译器和处理器&lt;strong&gt;对volatile变量与普通变量的重排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如何实现：&lt;strong&gt;内存屏障&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id="用途"&gt;用途
&lt;/h5&gt;&lt;p&gt;在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为“轻量级”的锁来用。但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;volatile仅仅保证对单个volatile变量的读/写具有原子性&lt;/li&gt;
&lt;li&gt;锁可以保证整个&lt;strong&gt;临界区代码&lt;/strong&gt;的执行具有原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="锁与synchronized"&gt;锁与synchronized
&lt;/h3&gt;&lt;p&gt;首先需要明确的一点是：&lt;strong&gt;Java多线程的锁都是基于对象的&lt;/strong&gt;，Java中的每一个对象都可以作为一个锁。&lt;/p&gt;
&lt;h4 id="synchronized关键字"&gt;Synchronized关键字
&lt;/h4&gt;&lt;p&gt;通常使用&lt;code&gt;synchronized&lt;/code&gt;关键字来给一段代码或一个方法上锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果加在类的普通方法上，则锁为调用该方法的实例&lt;/li&gt;
&lt;li&gt;如果加在类的静态方法上，由于调用静态方法是通过类名调用，所以锁为当前Class对象&lt;/li&gt;
&lt;li&gt;如果在方法里使用，锁为括号里面的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 关键字在实例方法上，锁为当前实例&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;instanceLock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// code&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 等价于&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;blockLock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// code&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 关键字在静态方法上，锁为当前Class对象&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;classLock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// code&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 等价于&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;blockLock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClass&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// code&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 关键字在代码块上，锁为括号里面的对象&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;blockLock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// code&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="class对象作为锁"&gt;Class对象作为锁
&lt;/h4&gt;&lt;p&gt;前面提到，Java中的每一个对象都可以作为一个锁。那就有同学要问了，如果将Class对象作为锁呢？&lt;/p&gt;
&lt;p&gt;由于每个类都有自己的Class对象，并且该类的所有实例都共享这个Class对象，所以如果将这个Class对象作为锁，则所有&lt;strong&gt;该类的实例都会共享这个锁&lt;/strong&gt;，此时这个锁就不是对象级别的，而是&lt;strong&gt;类级别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有两种方法可以使用Class对象作为锁：&lt;/p&gt;
&lt;p&gt;在 Java 中，锁确实是基于对象的，而 &lt;strong&gt;Class 对象&lt;/strong&gt; 也可以作为锁。Class 对象是 Java 中每个类在 JVM 中的运行时表示，每个类都有一个对应的 Class 对象。因此，Class 对象也可以作为锁来使用。&lt;/p&gt;
&lt;p&gt;可以通过以下方式使用 Class 对象作为锁：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;synchronized&lt;/code&gt; 块&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 使用 Class 对象作为锁&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 临界区代码&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;synchronized&lt;/code&gt; 静态方法，在静态方法上使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字时，锁是当前类的 Class 对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 使用 Class 对象作为锁&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 临界区代码&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Java多线程 - 一篇不太详细的解释</title><link>https://oddyti.com/post/multi-threading/</link><pubDate>Thu, 20 Feb 2025 17:31:03 +0800</pubDate><guid>https://oddyti.com/post/multi-threading/</guid><description>&lt;h2 id="多线程"&gt;多线程
&lt;/h2&gt;&lt;p&gt;Java 线程通常是 &lt;strong&gt;一对一模型&lt;/strong&gt;，即每个 Java 线程直接映射到一个操作系统内核线程。但某些 JVM 可能使用用户线程或混合模型（如 M:N 模型，多个用户线程映射到少量内核线程）。&lt;/p&gt;
&lt;h3 id="线程安全三原则"&gt;线程安全三原则
&lt;/h3&gt;&lt;p&gt;Java 线程安全的三个方面是：&lt;/p&gt;
&lt;h4 id="原子性"&gt;原子性
&lt;/h4&gt;&lt;p&gt;原子性指的是一个操作要么完全执行，要么完全不执行，不会出现部分执行的情况。在多线程环境下，如果操作不具备原子性，可能会导致数据不一致。（就像原子一样，不可分割）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字。来保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="可见性"&gt;可见性
&lt;/h4&gt;&lt;p&gt;可见性指的是一个线程对共享变量的修改对其他线程可见。在多线程环境下，如果缺乏可见性，可能会导致线程读取到过期的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;volatile&lt;/code&gt; 关键字，确保变量的修改对其他线程立即可见。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字，确保线程在释放锁之前将修改同步到主内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="有序性"&gt;有序性
&lt;/h4&gt;&lt;p&gt;有序性指的是程序执行的顺序符合预期，不会发生指令重排序。在多线程环境下，如果缺乏有序性，可能会导致程序行为异常。&lt;/p&gt;
&lt;h3 id="保证数据一致性的方案有哪些"&gt;保证数据一致性的方案有哪些
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;事务管理&lt;/li&gt;
&lt;li&gt;锁机制&lt;/li&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="创建线程的方式"&gt;创建线程的方式
&lt;/h3&gt;&lt;h4 id="继承thread类"&gt;继承Thread类
&lt;/h4&gt;&lt;p&gt;重写run方法。调用类对象的start方法启动线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以直接在run方法中使用this访问当前线程。&lt;/li&gt;
&lt;li&gt;可以直接调用 &lt;code&gt;Thread&lt;/code&gt; 类的方法（如 &lt;code&gt;getName()&lt;/code&gt;、&lt;code&gt;setPriority()&lt;/code&gt; 等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 不支持多继承，因此继承 &lt;code&gt;Thread&lt;/code&gt; 类后无法继承其他类。&lt;/li&gt;
&lt;li&gt;任务与线程耦合在一起，不符合面向对象的设计原则。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="实现-runnable-接口"&gt;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务与线程分离，符合面向对象的设计原则。&lt;/li&gt;
&lt;li&gt;可以继承其他类，灵活性更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要额外创建 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;无法直接调用 &lt;code&gt;Thread&lt;/code&gt; 类的方法（需要通过 &lt;code&gt;Thread.currentThread()&lt;/code&gt; 获取当前线程）。（即在重写的run方法中不能用this调用，需要用Thread.currentThread()）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="实现callable接口并包装仅futuretask类"&gt;实现Callable接口，并包装仅FutureTask类
&lt;/h3&gt;&lt;p&gt;通过实现 &lt;code&gt;Callable&lt;/code&gt; 接口并重写 &lt;code&gt;call()&lt;/code&gt; 方法来创建线程。需要包装进FutureTask，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口&lt;/p&gt;
&lt;p&gt;在 Java 中，&lt;code&gt;Runnable&lt;/code&gt; 接口的 &lt;code&gt;run()&lt;/code&gt; 方法 &lt;strong&gt;不能抛出受检异常（Checked Exception）&lt;/strong&gt;，因为 &lt;code&gt;run()&lt;/code&gt; 方法的签名没有声明 &lt;code&gt;throws&lt;/code&gt; 子句。如果尝试在 &lt;code&gt;run()&lt;/code&gt; 方法中抛出受检异常，编译器会报错。&lt;/p&gt;
&lt;p&gt;如果需要抛出受检异常并获取任务执行结果，可以使用 &lt;code&gt;Callable&lt;/code&gt; 接口替代 &lt;code&gt;Runnable&lt;/code&gt;。&lt;code&gt;Callable&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法可以抛出受检异常，并且可以返回结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.concurrent.Callable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.concurrent.FutureTask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyCallable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;implements&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;call&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;throws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;线程执行完成&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;throws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FutureTask&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futureTask&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FutureTask&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MyCallable&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futureTask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 启动线程&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futureTask&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 获取线程返回值&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="使用线程池"&gt;使用线程池
&lt;/h3&gt;&lt;p&gt;通过线程池（如 &lt;code&gt;ExecutorService&lt;/code&gt;）来管理线程的创建和执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExecutorService&lt;/code&gt; 的 &lt;code&gt;submit()&lt;/code&gt; 方法可以接受以下类型的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Runnable&lt;/code&gt; 任务&lt;/strong&gt;：返回 &lt;code&gt;Future&amp;lt;?&amp;gt;&lt;/code&gt;，任务没有返回值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Callable&lt;/code&gt; 任务&lt;/strong&gt;：返回 &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;，任务可以有返回值和抛出异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Runnable&lt;/code&gt; 任务 + 预定义结果&lt;/strong&gt;：返回 &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;，任务没有返回值，但可以指定一个结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他实现了 &lt;code&gt;Runnable&lt;/code&gt; 或 &lt;code&gt;Callable&lt;/code&gt; 的对象&lt;/strong&gt;：返回 &lt;code&gt;Future&amp;lt;?&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这个 &lt;code&gt;Future&lt;/code&gt; 对象可以用来检查任务是否完成，或者取消任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.concurrent.ExecutorService&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.concurrent.Executors&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExecutorService&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Executors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newFixedThreadPool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;submit&lt;/span&gt;&lt;span class="p"&gt;(()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;线程执行中&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;shutdown&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 关闭线程池&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="停止线程的方式"&gt;停止线程的方式
&lt;/h3&gt;&lt;h3 id="线程状态"&gt;线程状态
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NEW：创建，new一个线程对象&lt;/li&gt;
&lt;li&gt;RUNNABLE：表示线程已经启动，并且正在执行任务或准备执行任务。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RUNNABLE&lt;/code&gt; 状态并不一定意味着线程正在占用 CPU 资源。它只是表示线程已经准备好运行，是否真正运行取决于操作系统的调度。&lt;/li&gt;
&lt;li&gt;RUNNABL != RUNNING&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BLOCKED：处于BLOCKED状态的线程正等待锁的释放以进入同步区（获取同步资源）。
&lt;ul&gt;
&lt;li&gt;当线程尝试获取一个锁但锁已被其他线程占用时，线程会从 &lt;code&gt;RUNNABLE&lt;/code&gt; 状态进入 &lt;code&gt;BLOCKED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WAITING：处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。
&lt;ul&gt;
&lt;li&gt;线程调用 &lt;code&gt;Object.wait()&lt;/code&gt; 方法，等待其他线程调用 &lt;code&gt;Object.notify()&lt;/code&gt; 或 &lt;code&gt;Object.notifyAll()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;线程调用 &lt;code&gt;Thread.join()&lt;/code&gt; 方法，等待其他线程执行完成。（底层还是用&lt;code&gt;Object.wait()&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;线程调用 &lt;code&gt;LockSupport.park()&lt;/code&gt; 方法，等待其他线程调用 &lt;code&gt;LockSupport.unpark()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TIMED_WAITING：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep(long millis)&lt;/code&gt;：使当前线程睡眠指定时间；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.wait(long timeout)&lt;/code&gt;：线程休眠指定时间，等待期间可以通过&lt;code&gt;notify()&lt;/code&gt;/&lt;code&gt;notifyAll()&lt;/code&gt;唤醒；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.join(long millis)&lt;/code&gt;：等待当前线程最多执行&lt;code&gt;millis&lt;/code&gt;毫秒，如果&lt;code&gt;millis&lt;/code&gt;为0，则会一直执行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LockSupport.parkNanos(long nanos)&lt;/code&gt;： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LockSupport.parkUntil(long deadline)&lt;/code&gt;：同上，也是禁止线程进行调度指定时间；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TERMINATED：终止状态。此时线程已执行完毕。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://oddyti.com/java-thread-status.png"
loading="lazy"
alt="线程状态转换图"
&gt;&lt;/p&gt;
&lt;h3 id="锁机制"&gt;锁机制
&lt;/h3&gt;&lt;p&gt;是的！在 Java 中，如果你想实现 &lt;strong&gt;多线程的同步&lt;/strong&gt;（即控制多个线程之间的执行顺序或共享资源的访问），通常需要创建一个 &lt;strong&gt;锁对象&lt;/strong&gt;（如 &lt;code&gt;Object lock&lt;/code&gt;），并通过这个锁来控制各个线程的行为。锁对象是多线程同步的核心工具。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id="1-为什么需要锁对象"&gt;1. 为什么需要锁对象？
&lt;/h4&gt;&lt;p&gt;在多线程环境中，多个线程可能会同时访问共享资源（如变量、集合、文件等），如果没有同步机制，可能会导致 &lt;strong&gt;数据竞争&lt;/strong&gt; 和 &lt;strong&gt;不一致性&lt;/strong&gt;。锁对象的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥访问&lt;/strong&gt;：确保同一时刻只有一个线程可以访问共享资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程协作&lt;/strong&gt;：通过 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 实现线程之间的通信和协作。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="2-如何使用锁对象"&gt;2. 如何使用锁对象？
&lt;/h4&gt;&lt;p&gt;以下是使用锁对象实现多线程同步的步骤：&lt;/p&gt;
&lt;p&gt;(1) 创建一个锁对象&lt;/p&gt;
&lt;p&gt;java&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(2) 使用 &lt;code&gt;synchronized&lt;/code&gt; 保护共享资源&lt;/p&gt;
&lt;p&gt;java&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 访问共享资源的代码&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) 使用 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 实现线程协作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;：让当前线程等待，并释放锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notify()&lt;/code&gt;：唤醒在同一个锁上等待的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="3-示例使用锁对象实现多线程同步"&gt;3. 示例：使用锁对象实现多线程同步
&lt;/h4&gt;&lt;p&gt;以下是一个生产者-消费者模型的示例，展示了如何使用锁对象控制多个线程的同步：&lt;/p&gt;
&lt;p&gt;java&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;span class="lnt"&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ProducerConsumerExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 锁对象&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataReady&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 数据是否准备好的标志&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;生产者开始生产数据...&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 模拟生产数据的耗时&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataReady&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 数据生产完成&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 通知消费者线程&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;生产者生产数据完成，并通知消费者&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;消费者等待数据...&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;dataReady&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 如果数据未准备好&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 消费者线程等待&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;消费者消费数据完成&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 启动消费者线程&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 主线程休眠1秒，确保消费者线程先进入等待状态&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 启动生产者线程&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item></channel></rss>