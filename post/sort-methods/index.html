<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='简单总结了常见的排序算法'><title>排序算法总结</title><link rel=canonical href=https://oddyti.com/post/sort-methods/><link rel=stylesheet href=/scss/style.min.77bf451fb2a8bb281109df0e609a8cf50ab757186aa4c18810759a4decb09442.css><meta property='og:title' content='排序算法总结'><meta property='og:description' content='简单总结了常见的排序算法'><meta property='og:url' content='https://oddyti.com/post/sort-methods/'><meta property='og:site_name' content='Oddyti的小站'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='算法'><meta property='article:published_time' content='2024-12-12T10:41:27+08:00'><meta property='article:modified_time' content='2024-12-12T10:41:27+08:00'><meta name=twitter:title content="排序算法总结"><meta name=twitter:description content="简单总结了常见的排序算法"><link rel="shortcut icon" href=/favicon2.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/snoopy_hu_8a95909abaef0cd8.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Oddyti的小站</a></h1><h2 class=site-description>是谁来自山川湖海，却囿于昼夜厨房与爱。</h2></div></header><ol class=social-menu><li><a href=https://space.bilibili.com/51329228 target=_blank title=Biligili rel=me><svg t="1698647251144" class="icon" viewBox="0 0 1024 1024" p-id="3988" width="200" height="200"><path d="M306.005333 117.632 444.330667 256h135.296l138.368-138.325333A42.666667 42.666667.0 01778.368 178.048L700.330667 256H789.333333A149.333333 149.333333.0 01938.666667 405.333333v341.333334A149.333333 149.333333.0 01789.333333 896H234.666667A149.333333 149.333333.0 0185.333333 746.666667V405.333333A149.333333 149.333333.0 01234.666667 256h88.96L245.632 177.962667a42.666667 42.666667.0 0160.373333-60.373334zm483.328 223.701333H234.666667a64 64 0 00-63.701334 57.856L170.666667 405.333333v341.333334a64 64 0 0057.856 63.701333L234.666667 810.666667h554.666666a64 64 0 0063.701334-57.856L853.333333 746.666667V405.333333a64 64 0 00-64-64zm-448 128A42.666667 42.666667.0 01384 512v85.333333a42.666667 42.666667.0 01-85.333333.0V512a42.666667 42.666667.0 0142.666666-42.666667zm341.333334.0A42.666667 42.666667.0 01725.333333 512v85.333333a42.666667 42.666667.0 01-85.333333.0V512a42.666667 42.666667.0 0142.666667-42.666667z" p-id="3989"/></svg></a></li><li><a href='https://music.163.com/#/user/home?id=556522560' target=_blank title=网易云 rel=me><svg t="1698647303353" class="icon" viewBox="0 0 1024 1024" p-id="5301" width="200" height="200"><path d="M616.64142222 49.16337778c25.14488889-7.24764445 52.08746667-6.88355555 77.48266667-1.04675556 29.16124445 6.92906667 56.75235555 20.32071111 80.49777778 38.57066667 8.66986667 6.58773333 16.49777778 14.77973333 20.48 25.088 6.16675555 15.24622222 4.51697778 33.47342222-4.58524445 47.2064-7.94168889 12.33351111-21.44711111 20.92373333-35.99928889 22.76693333-11.62808889 1.59288889-23.81368889-.87608889-33.80337778-7.05422222-5.632-3.31093333-9.92142222-8.41955555-15.57617777-11.69635555-15.16657778-9.6256-32.63146667-17.2032-50.8928-16.77084445-12.85688889.14791111-24.1664 7.68-32.88177778 16.53191111-8.15786667 8.41955555-12.31075555 20.83271111-9.61422222 32.38115556 6.26915555 23.59751111 12.50417778 47.19502222 18.76195555 70.79253333 44.98773333 2.30968889 89.95271111 14.21084445 128.62577778 37.69457778 37.59217778 23.25617778 71.55484445 52.74737778 98.48604444 87.89333333 22.85795555 29.78702222 40.18631111 63.80657778 50.7904 99.82862222 11.48017778 38.82097778 15.20071111 79.75822222 12.20835556 120.08106667-2.49173333 33.26862222-9.03395555 66.34382222-20.32071111 97.78062222-29.184 76.54968889-83.23982222 143.6672-152.81493333 187.16444445-51.02933333 32.23324445-109.63626667 51.67786667-169.40373334 59.09617778-41.25582222 5.15413333-83.29671111 5.17688889-124.34773333-1.85457778C369.37955555 939.67928889 290.32675555 897.6384 230.33173333 836.9152 170.71217778 777.18186667 129.21742222 699.65368889 112.4352 616.94862222c-12.37902222-60.3136-11.82151111-123.2896 1.91146667-183.33013333 16.78222222-74.0352 53.87377778-143.29173333 106.01813333-198.43982222 42.53013333-45.28355555 95.06133333-81.11217778 152.72391111-104.2432 5.9392-2.26417778 11.78737778-4.94933333 18.11342222-5.95057778 13.50542222-2.36657778 27.93244445.83057778 38.99164445 8.97706666 14.97315555 10.56995555 23.21066667 29.74151111 20.71893333 47.8776889C448.85333333 200.3512889 435.712 217.0424889 418.2016 223.37991111c-58.25422222 21.77706667-109.90933333 60.68906667-147.09191111 110.51235556-33.23448889 44.21404445-54.92053333 97.02968889-62.19093334 151.88195555-7.33866667 54.29475555-.80782222 110.36444445 18.64817778 161.56444445 28.10311111 74.8544 83.97937778 139.264 155.21564445 175.9232 42.89422222 22.2208 91.18151111 33.82613333 139.48017777 33.49617778 39.7312-.512 79.58755555-6.89493333 116.92942223-20.70755556 32.83626667-12.19697778 63.61315555-30.208 89.78204444-53.5552 24.39395555-21.61777778 44.69191111-47.74115555 60.17706667-76.40177778 7.75964445-14.62044445 14.92764445-29.67324445 19.30808889-45.68177778 12.92515555-45.76142222 15.16657778-95.35715555 1.34257777-141.18684444-11.43466667-38.43413333-34.96391111-72.69262222-65.01262222-99.00942222-13.28924445-11.62808889-27.48871111-22.28906667-42.71217778-31.25475556-13.44853333-7.55484445-28.13724445-12.6976-43.12177777-16.21333333 10.4448 40.84622222 21.61777778 81.52177778 32.21048889 122.33386667 1.79768889 9.78488889 3.59537778 19.56977778 5.27928888 29.37742222 1.54737778 42.10915555-13.22097778 84.52551111-40.37973333 116.736-25.30417778 30.35591111-61.2352 51.712-100.10168889 59.05066666-41.89297778 8.35128889-86.9376.46648889-122.91413333-22.75555555-34.34951111-21.77706667-59.72195555-56.26311111-73.10222222-94.43555556-7.5776-21.35608889-11.35502222-43.94097778-12.10595556-66.56-2.29831111-49.20888889 10.56995555-99.48728889 38.71857778-140.1856 33.0752-48.57173333 85.21955555-81.96551111 141.12995555-98.25848889-4.11875555-15.74684445-8.32853333-31.47093333-12.4928-47.21777778-10.79751111-33.98542222-8.4992-72.14648889 7.61173334-104.09528888 8.69262222-17.82897778 21.61777778-33.35964445 36.56817778-46.27342222 16.64568889-14.2336 36.07893333-25.47484445 57.26435555-31.30026667m-133.49546667 370.176c-14.99591111 15.74684445-25.50897778 35.65795555-30.03733333 56.91164444-4.07324445 19.29671111-4.096 39.41262222-.43235555 58.76622223 4.47146667 21.37884445 15.50791111 42.2912 33.80337778 54.90915555 14.19946667 10.08071111 32.68835555 13.14133333 49.62986666 9.8304 31.34577778-5.50684445 56.92302222-34.34951111 57.79911111-66.26417778-1.19466667-7.90755555-2.50311111-15.81511111-4.73315555-23.50648889-11.70773333-44.28231111-23.51786667-88.53048889-35.15733334-132.83555555-26.48746667 8.16924445-51.70062222 21.93635555-70.87217778 42.1888z" p-id="5302"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/categories><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>分类</span></a></li><li><a href=/archives><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/tags><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>标签</span></a></li><li><a href=/links><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://oddyti.com/ selected>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#插入排序insertion-sort>插入排序（Insertion Sort）</a><ol><li><a href=#代码实现>代码实现</a></li><li><a href=#复杂度分析>复杂度分析</a></li></ol></li><li><a href=#希尔排序shell-sort>希尔排序（Shell Sort）</a><ol><li><a href=#代码实现-1>代码实现</a></li><li><a href=#复杂度分析-1>复杂度分析</a></li></ol></li><li><a href=#选择排序selection-sort>选择排序（Selection Sort）</a><ol><li><a href=#代码实现-2>代码实现</a></li><li><a href=#复杂度分析-2>复杂度分析</a></li></ol></li><li><a href=#堆排序>堆排序</a><ol><li><a href=#堆>堆</a></li><li><a href=#堆排序-1>堆排序</a><ol><li><a href=#代码实现-3>代码实现</a></li></ol></li></ol></li><li><a href=#冒泡排序bubble-sort>冒泡排序（Bubble Sort）</a><ol><li><a href=#代码实现-4>代码实现</a></li><li><a href=#复杂度分析-3>复杂度分析</a></li></ol></li><li><a href=#快速排序>快速排序</a><ol><li><a href=#代码实现-5>代码实现</a></li><li><a href=#改进>改进</a><ol><li><a href=#随机选择基准>随机选择基准</a></li><li><a href=#采用双指针对分区步骤进行改进>采用双指针对分区步骤进行改进</a></li></ol></li></ol></li><li><a href=#归并排序>归并排序</a><ol><li><a href=#代码实现-6>代码实现</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E6%8A%80%E6%9C%AF/>技术</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/sort-methods/>排序算法总结</a></h2><h3 class=article-subtitle>简单总结了常见的排序算法</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 12, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 12 分钟</time></div></footer></div></header><section class=article-content><h2 id=插入排序insertion-sort>插入排序（Insertion Sort）</h2><p><img src=/post/sort-methods/InsertionSort.gif width=811 height=505 loading=lazy alt=img class=gallery-image data-flex-grow=160 data-flex-basis=385px></p><p>插入排序可以说是最直观的排序算法，简单而言，假设该位置的元素之前已经为排序好的升序，那么我将该元素从此位置依次从后往前与排序好的元素比较，如果更小，则交换，直到找到比该元素小的。</p><p>需要两层循环，第一层循环从第二个元素开始递增，循环变量<code>i</code>，<code>arr[i]</code>即找到本次需要被插入的元素。</p><p>第二层循环从该元素位置开始，循环变量<code>j</code>，比较该位置元素<code>arr[j]</code>和前一个元素<code>arr[j-1]</code>，如果符合条件，则交换，然后递减，直到比较到第2个元素<code>arr[j=1]</code>和第1个元素<code>arr[j-1=0]</code>。所以是j大于0截止。</p><h3 id=代码实现>代码实现</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>insertionSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>--</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=复杂度分析>复杂度分析</h3><p>时间复杂度：</p><p>最坏情况：$O(n^2)$</p><p>即每个位置的元素都需要和前面的元素交换一次，总操作次数为：
$$
0 + 1 + 2 + 3 +&mldr;+ n = \frac{1}{2}n (n -1) \
O\left(\frac{1}{2}n (n -1)\right) =O(n^2)
$$
最好情况：$O(n)$</p><p>平均：$O(n^2)$</p><p>空间复杂度：$O(1)$</p><p>只有交换时产生额外空间，所以是$O(1)$</p><h2 id=希尔排序shell-sort>希尔排序（Shell Sort）</h2><p>在我理解中，直接插入排序可以看作是希尔排序<code>gap</code>为<code>1</code>的情况。</p><p><strong>希尔排序的<code>gap</code>,减为<code>1</code>时，就退化成直接插入排序；反过来将，如果将直接插入排序中循环变量涉及到的增量和起始量换成<code>gap</code>，再让<code>gap</code>减为<code>1</code>，不就进化成了希尔排序了吗</strong></p><p>希尔排序简单来说就是将数组进行分组后，对每个组进行一次插入排序，分组数量不断减少，直到减少到<code>1</code>，退化为直接插入排序。</p><p><img src=/post/sort-methods/ShellSort.webp width=773 height=598 loading=lazy alt=ShellSort class=gallery-image data-flex-grow=129 data-flex-basis=310px></p><p>如对于图中例子，初始数组为[9,1,2,5,7,4,8,6,3,5]， 每次按照gap对数组进行分组，每次分组排序结束后，gap减半，直到减为1。</p><p>第一次分组：gap = length/2 = 5，分为(9,4), (1,8), (2,6), (5,3), (7,5)子组，然后对这些子组分别进行一次插入排序。</p><p>第二次分组：gap = gap/2 = 2，分为(4,2,5,8,5), (1,3,9,6,7)两组，然后对这两个子组进行插入排序。</p><p>第三次分组：gap = gap/2 = 1。退化为直接插入排序。排序后得到结果。</p><h3 id=代码实现-1>代码实现</h3><p>代码实现上，因为直接插入排序即<code>gap = 1</code>时的希尔排序，我们可以反过来看，那么希尔排序不就是将直接插入排序中的本来为<code>1</code>的间隔替换为不同的<code>gap</code>吗？所以我们可以将直接插入排序的代码中，循环变量涉及到的增量和起始量替换为<code>gap</code>，并且在外层套一个递减<code>gap</code>的循环，这样就可以得到希尔排序算法代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>myShellSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>gap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=o>/</span><span class=n>2</span><span class=p>;</span><span class=w> </span><span class=n>gap</span><span class=o>&gt;</span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>gap</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=n>2</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 下面的代码即将直接插入排序的代码中的递增量和起始量换成了gap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gap</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>&gt;=</span><span class=w> </span><span class=n>gap</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>gap</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>gap</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>gap</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>gap</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=复杂度分析-1>复杂度分析</h3><p>最坏情况：$O(n²)$，在某些情况下，性能接近于插入排序。</p><p>平均情况：$O(n^{\frac{3}{2}})$，具体取决于间隔的选择。</p><p>最好情况：$O(n)$，当数组已经接近排序时。</p><p><strong>希尔排序平均时间复杂度比直接插入好的原因可以理解为：在开始时，对数组进行较多分组后插入排序，操作次数少的同时，减少了数组中的乱序性；到分组变少后，虽然每个组中的数更多了，但是由于数组的整体乱序性已经降低，所以操作次数也会变少。</strong></p><p>空间复杂度：O(n)</p><p>稳定性：不稳定（分组时，可能两个相等的元素在不同组，从而会出现顺序变换的情况）</p><h2 id=选择排序selection-sort>选择排序（Selection Sort）</h2><p><img src=/post/sort-methods/SelectionSort.gif width=811 height=248 loading=lazy alt=SelectionSort class=gallery-image data-flex-grow=327 data-flex-basis=784px></p><p>选择排序是一种非常简单和直观的排序算法，即从未排序的数组中找到最小的元素，放在已排序的数组之后。</p><h3 id=代码实现-2>代码实现</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>selectionSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>minIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 找到未排序序列中最小的元素索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>minIndex</span><span class=o>]</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>minIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 交换第一个未排序的元素和最小元素</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>minIndex</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>minIndex</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=复杂度分析-2>复杂度分析</h3><p>无论什么样的数组，都会是$O(n^2)$的时间复杂度</p><h2 id=堆排序>堆排序</h2><p>参考：<a class=link href=https://aijishu.com/a/1060000000090217 target=_blank rel=noopener>三分钟玩转堆排序原理及面试题（多图解释+Python实现） - 极术社区 - 连接开发者与智能计算生态</a></p><p>堆排序是基于堆，一种完全二叉树的数据结构的高效排序算法。</p><h3 id=堆>堆</h3><p>堆实际上是一个完全二叉树数据结构。即除了最下面一层以外，其余各层的结点都达到最大个数，最下面一层的所有结点都连续集中在最左边。</p><p><img src=/post/sort-methods/wanquanerchashu.png width=818 height=313 loading=lazy alt=wanquanerchashu class=gallery-image data-flex-grow=261 data-flex-basis=627px></p><p>堆分为：大顶堆和小顶堆</p><ul><li>大顶堆：最大元素在根结点</li><li>小顶堆：最小元素在根结点</li></ul><p><img src=/post/sort-methods/daxiaodingdui.png width=845 height=293 loading=lazy alt=daxiaodingdui class=gallery-image data-flex-grow=288 data-flex-basis=692px></p><h3 id=堆排序-1>堆排序</h3><p>堆排序的思路很简单：即从大顶堆中弹出最大的元素，然后将最后一个元素放在空出来的根节点，调整剩下的堆序性，再弹出次大的元素，重复这个过程，最后便得到有序的序列。考虑到空间复杂度，弹出的元素并不需要存放在新开辟的空间中，可以直接与最后一个元素交换位置，调整剩下的堆。整个过程如下：</p><ol><li>将未排序的数组构造成大顶堆</li><li>将大顶堆的根元素与堆的最后一个元素交换，调整剩下的堆</li><li>重复2</li></ol><p>最终堆数组便成为了一个升序的数组。</p><h4 id=代码实现-3>代码实现</h4><p>主逻辑</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>heapSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 构造大顶堆，从最后一个父结点开始自下而上下沉</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>&gt;=</span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>--</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 弹出交换 调整堆</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>&gt;=</span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>--</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>细节：</p><ul><li>构造堆的方法为<strong>自下而上的构造法</strong>，从最后一个父结点开始，进行下沉操作，每次下沉后，将操作过的子结点看作父节点进行递归，以保证所有子堆都满足堆序性</li></ul><p>构造堆递归方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>heapify</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 找到父结点、左右结点中最大的元素</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>largest</span><span class=o>]</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>right</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>right</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>largest</span><span class=o>]</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果父结点不为最大，交换；并对交换后的结点进行下沉优化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>largest</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>i</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>largest</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>largest</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>踩坑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>right</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>largest</span><span class=o>]</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>应该先判断<code>right &lt; n</code>再<code>arr[right] > arr[largest]</code>，否则会越界</p><h2 id=冒泡排序bubble-sort>冒泡排序（Bubble Sort）</h2><p><img src=/post/sort-methods/BubbleSort.gif width=826 height=257 loading=lazy alt=BubbleSort class=gallery-image data-flex-grow=321 data-flex-basis=771px></p><p>冒泡排序虽然叫做冒泡，听起来像是操作一个最大元素上浮，但是实际上操作的对象是一个移动的框，依次移动这个框，然后判断框内的元素是否符合大小顺序，如果不符合则交换，符合则将框后移，直到移动到已排序的元素之前停止。</p><h3 id=代码实现-4>代码实现</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>bubbleSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=w> </span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=复杂度分析-3>复杂度分析</h3><p><strong>时间复杂度</strong>：</p><ul><li>最坏情况：$O(n^2)$</li><li>平均情况：$O(n^2)$</li><li>最好情况：$O(n)$</li></ul><p><strong>空间复杂度</strong>：$O(1)$</p><h2 id=快速排序>快速排序</h2><p>参加：<a class=link href=https://www.geeksforgeeks.org/improvement-on-the-quick-sort-algorithm/ target=_blank rel=noopener>Improvement on the Quick Sort Algorithm - GeeksforGeeks</a></p><ul><li>分治</li><li>递归</li></ul><p>快速排序的基本思想为选取一个基准元素，然后将数组分为小于基准元素和大于基准元素的两部分，并对分出来的两部分进行同样的操作，直到无法再分。</p><p>可以使用这个题来进行测试 <a class=link href=https://leetcode.cn/problems/sort-an-array/ target=_blank rel=noopener>912. 排序数组</a></p><h3 id=代码实现-5>代码实现</h3><p>此版本为最基础的版本，采用递归。</p><ul><li><p><code>quickSort(int[] arr, int left, int right)</code>: 递归入口</p></li><li><p><code>partition(int[] arr, int left, int right)</code>: 核心方法，负责对传入的数组进行划分，得到划分后的基准元素索引和数组。</p></li><li><p><code>swap(int[] arr, int i, int j)</code>: 交换两个元素位置</p></li></ul><p>对于一个数组，传进<code>quickSort()</code>方法后，先进行划分，得到划分后的数组和基准元素的索引，然后再根据基准元素索引数组分为两个子数组，分别递归<code>quickSort()</code>方法。递归退出条件为当传入的数组只有两个元素且顺序正确，此时<code>left = right</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>quickSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 递归退出条件：最深层穿进来的数组的左索引 = 右索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=c1>// 最左元素为基准元素</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>lastIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w> </span><span class=c1>// 最后一个小于基准元素位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 判断arr[i]是否小于基准，如果小于则交换上一个和这个的位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>pivot</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lastIndex</span><span class=w> </span><span class=o>++</span><span class=p>;</span><span class=w> </span><span class=c1>// 右移到下一个即第一个不小于基准元素，然后交换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>lastIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将基准放在最后一个小于其的位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>lastIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>lastIndex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>问题</strong></p><p>在测试过程中，遇到了两个极端测试样例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>arr1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>[</span><span class=n>3</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,...,</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>arr2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>[</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,</span><span class=n>2</span><span class=p>,...,</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>即大量重复元素问题，由于每次选择的是第一个元素为基准元素，并且是简单的单向指针，所以对于重复元素数组，每次分区之后都会分成N-1和1，因此整体时间复杂度将为$O(N^2)$会超出时间限制</p><h3 id=改进>改进</h3><h4 id=随机选择基准>随机选择基准</h4><p>基础算法中，基准选择是直接选择数组第一个元素，那么如果数组已经是有序或者逆序，则每次分区都会是极端情况，算法复杂度会非常高。</p><h4 id=采用双指针对分区步骤进行改进>采用双指针对分区步骤进行改进</h4><p>在基础的分区算法中，是从最左边元素开始进行遍历，与基准值比较后进行交换。改进思路：采用双指针，从两端开始扫描元素，分别找小于基准和大于基准的元素进行交换，直到两个指针反转，最后将基准元素和任一分区靠近中间的端点交换。</p><p>改进后的分区方法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>quickSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 递归退出条件：最深层穿进来的数组的左索引 = 右索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>注意这里有一个非常容易才坑的地方，即得到<code>pivotIndex</code>之后，分区是否要包含<code>pivotIndex</code>所在的元素。</p><p>如果<code>partition</code>方法中，返回的index的的确确是真正的pivotIndex，那么之后的分区可以不包含，例如基础快排中方法中，在方法末位我们将基准元素放到了lastIndex并返回，所以返回的就是真正的pivotIndex</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=c1>// 最左元素为基准元素</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>lastIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w> </span><span class=c1>// 最后一个小于基准元素位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 判断arr[i]是否小于基准，如果小于则交换上一个和这个的位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>pivot</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lastIndex</span><span class=w> </span><span class=o>++</span><span class=p>;</span><span class=w> </span><span class=c1>// 右移到下一个即第一个不小于基准元素，然后交换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>lastIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将基准放在最后一个小于其的位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>lastIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>lastIndex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>但是如果<code>partition</code>方法中，返回的index的并非真正的pivotIndex，例如网上许多Hoare’s Partition的代码中，返回的是小于基准元素的自区间的最后一个元素的位置，并非Pivot Index。例如这个代码<a class=link href=https://www.geeksforgeeks.org/hoares-vs-lomuto-partition-scheme-quicksort/ target=_blank rel=noopener>Hoare&rsquo;s vs Lomuto partition scheme in QuickSort - GeeksforGeeks</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/* This function takes first element as pivot, and
</span></span></span><span class=line><span class=cl><span class=cm>   places all the elements smaller than the pivot on the
</span></span></span><span class=line><span class=cl><span class=cm>   left side and all the elements greater than the pivot
</span></span></span><span class=line><span class=cl><span class=cm>   on the right side. It returns the index of the last
</span></span></span><span class=line><span class=cl><span class=cm>   element on the smaller side*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>high</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>low</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>low</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>high</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Find leftmost element greater</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// than or equal to pivot</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>pivot</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Find rightmost element smaller</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// than or equal to pivot</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>j</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>pivot</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// If two pointers met.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>temp</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// swap(arr[i], arr[j]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=cm>/* The main function that
</span></span></span><span class=line><span class=cl><span class=cm>   implements QuickSort
</span></span></span><span class=line><span class=cl><span class=cm>arr[] --&gt; Array to be sorted,
</span></span></span><span class=line><span class=cl><span class=cm>low --&gt; Starting index,
</span></span></span><span class=line><span class=cl><span class=cm>high --&gt; Ending index */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>quickSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>high</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>low</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>high</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/* pi is partitioning index,
</span></span></span><span class=line><span class=cl><span class=cm>        arr[p] is now at right place */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=n>high</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Separately sort elements before</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// partition and after partition</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>high</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>待排序数组：[4, 1, 3]</p><p>第一次循环，选取pivot为4，左指针在4停止L=0，右指针在3停止R=2，交换得到[3, 1, 4]</p><p>第二次循环，左指针L继续扫描，在4停止L=2，右指针在1停止R=1，满足相遇条件，返回R=1</p><p><strong>此时返回的就不是真正的pivot位置，而是小于pivot的分区的末位位置，所以在主方法中，得到<code>partition</code>返回的index之后，分区递归调用时，不能将返回的index排除在外</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=p>);</span><span class=w> </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>high</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>而非</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=n>quickSort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>high</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>当然，如果写的Hoare’s Partition的<code>partition</code>方法最后是将基准元素放在两个分区之间后再返回真正的Pivot Index，则递归主方法在进行分区调用递归时，可以不包含Pivot元素。但是这样的话<code>partition</code>方法的逻辑上会相对更复杂，需要保证相遇情况下，右指针一定要指向小于基准元素分区的最后一个元素位置。</p><p>如在我写的方法中，随机选择pivot后，将其交换到最左边，然后对剩下的数组进行分区划分，但是这样情况下，剩下的数组里可能不会出现pivot，左右指针可能会出现越界情况，所以为了防止越界，我进行了两个越界判定。将左指针的最大设置为right，右指针最小设置为left，这里之所以不将右指针最小设置为left + 1，正是为了保证在极端情况下（如所有元素都大于pivot）右指针最后能指向pivot，这样才能保证最后在将pivot和右指针交换时<code>swap(arr, left, rP);</code>，不会出错。：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>partitionImprove</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Random</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Random</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>pivotIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=na>nextInt</span><span class=p>(</span><span class=n>right</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>pivotIndex</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>lP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>rP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=p>(</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>lP</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>lP</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lP</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=p>(</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>rP</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>pivot</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>rP</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>left</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>rP</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>lP</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>rP</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>lP</span><span class=p>,</span><span class=w> </span><span class=n>rP</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lP</span><span class=w> </span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rP</span><span class=w> </span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>swap</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>rP</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>rP</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>举个例子：</p><p>待排序数组：[3,4] left = 0, right = 1</p><p>随机选取pivot为3并将其交换到首位，此时数组：[3,4]</p><p>第一次循环，左指针从索引1开始扫描，3=pivot，停止，L=1；右指针从right扫描，由于将pivot位置也即索引0位置包含在右指针扫描范围中，所以右指针最终停止在0位置，R=0；左右指针相遇，推出循环。</p><p>交换pivotIndex(0)和R(0)，没问题。</p><p>但是如果由于将pivot位置也即索引0位置没有包含在右指针扫描范围内，则R会在1位置停止，此时也满足L==R，左右指针相遇。此后再交换</p><p>交换pivotIndex(0)和R(1)，那么pivot就会换走，此时返回的R位置虽然是pivot的位置，数组变为[4,3]，但是大于pivot的元素4已经被换到pivot（3）之前了。</p><p><strong>所以分区方法中，如果是将随机选出来的基准元素放在最左边，并对剩下的元素进行扫描时，那么一定要保证右指针的扫描范围也要包含基准元素。（如果将基准元素放在末尾，则需要对左指针进行同样的操作）</strong></p><h5 id=三向分区>三向分区</h5><p>为了有效地将具有大量重复键的阵列排序，可以讲分区分为三部分，严格小于基准、等于基准、大于基准</p><p><strong>未完待续</strong></p><h2 id=归并排序>归并排序</h2><p>核心操作：</p><p>合并两个有序数组</p><p>核心思想：</p><p>分而治之</p><p><img src=/post/sort-methods/image-20241209183344742.png width=676 height=690 loading=lazy alt=image-20241209183344742 class=gallery-image data-flex-grow=97 data-flex-basis=235px></p><h3 id=代码实现-6>代码实现</h3><p>合并操作</p><p>思路：</p><ul><li>三个指针分别扫描left、right、arr</li><li>比较扫描到的left和right的元素，将更小的放进arr</li><li>直到left或right扫描结束</li><li>将left或right中剩下的元素放进arr</li></ul><p>分治递归</p><p>思路：</p><ul><li>将数组分为两部分，分别进行分治，递归直到数组只剩下一个元素，然后将反过来合并，直到退出</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>mergeSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 退出判断</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mid</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>arraycopy</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>arraycopy</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mergeSort</span><span class=p>(</span><span class=n>left</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mergeSort</span><span class=p>(</span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>merge</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>merge</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right</span><span class=p>.</span><span class=na>length</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>right</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>arr</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>k</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>arr</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>k</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>j</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 处理有剩余的元素</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=na>length</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>k</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right</span><span class=p>.</span><span class=na>length</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arr</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>k</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>j</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/%E7%AE%97%E6%B3%95/>算法</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/thread-pool/><div class=article-details><h2 class=article-title>Java线程池(Thread Pool) - 一篇不太详细的解释</h2></div></a></article><article><a href=/post/jmm/><div class=article-details><h2 class=article-title>Java内存模型(JMM) - 一篇不太详细的解释</h2></div></a></article><article><a href=/post/multi-threading/><div class=article-details><h2 class=article-title>Java多线程 - 一篇不太详细的解释</h2></div></a></article><article><a href=/post/lambda/><div class=article-details><h2 class=article-title>Java基础 - 从匿名内部类到Lambda表达式再到方法引用</h2></div></a></article><article><a href=/post/texlive/><div class=article-details><h2 class=article-title>TeXLive+ VSCode 安装与环境配置</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=Oddyti/Giscus data-repo-id=R_kgDOKmaUDg data-category=Announcements data-category-id=DIC_kwDOKmaUDs4CahZG data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"transparent_dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Oddyti</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.21.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&family=Long+Cang&family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@300&family=Zhi+Mang+Xing&display=swap" rel=stylesheet></body></html>